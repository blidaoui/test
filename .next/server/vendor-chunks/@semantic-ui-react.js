"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@semantic-ui-react";
exports.ids = ["vendor-chunks/@semantic-ui-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/@semantic-ui-react/event-stack/lib/cjs/event-stack.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@semantic-ui-react/event-stack/lib/cjs/event-stack.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar env = __webpack_require__(/*! exenv */ \"(ssr)/./node_modules/exenv/index.js\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\n/**\n * The current implementation was chosen by performance and compatibility reasons, feel free to play\n * with benchmarks and submit PR with faster alternative. Each method contains links to benchmarks.\n */\nvar EventSet =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @see https://jsperf.com/suir-eventset-constructor\n   */\n  function EventSet(eventHandlers) {\n    _classCallCheck(this, EventSet);\n\n    _defineProperty(this, \"handlers\", void 0);\n\n    this.handlers = eventHandlers.slice(0);\n  }\n  /**\n   * @see https://jsperf.com/suir-eventset-addhandlers\n   */\n\n\n  _createClass(EventSet, [{\n    key: \"addHandlers\",\n    value: function addHandlers(additionalHandlers) {\n      var newHandlers = this.handlers.slice(0);\n      var length = additionalHandlers.length; // Heads up!\n      // Previously we use Set there, it granted uniqueness of handlers, now dispatchEvent() is\n      // responsible for this.\n\n      for (var i = 0; i < length; i += 1) {\n        newHandlers.push(additionalHandlers[i]);\n      }\n\n      return new EventSet(newHandlers);\n    }\n    /**\n     * @see https://jsperf.com/suir-eventset-dispatchsingle\n     * @see https://jsperf.com/suir-eventset-dispatchmultiple2\n     */\n\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event, dispatchAll) {\n      var count = this.handlers.length - 1;\n\n      if (!dispatchAll) {\n        // Heads up!\n        // We don't use .pop() there because it will mutate the array.\n        var recentHandler = this.handlers[count];\n        recentHandler(event);\n        return;\n      }\n\n      for (var i = count; i >= 0; i -= 1) {\n        if (!this.handlers[i].called) {\n          this.handlers[i].called = true;\n          this.handlers[i](event);\n        }\n      }\n\n      for (var _i = count; _i >= 0; _i -= 1) {\n        this.handlers[_i].called = false;\n      }\n    }\n  }, {\n    key: \"hasHandlers\",\n    value: function hasHandlers() {\n      return this.handlers.length > 0;\n    }\n    /**\n     * @see https://jsperf.com/suir-eventset-removehandlers\n     */\n\n  }, {\n    key: \"removeHandlers\",\n    value: function removeHandlers(removalHandlers) {\n      var newHandlers = [];\n      var length = this.handlers.length;\n\n      for (var i = 0; i < length; i += 1) {\n        var handler = this.handlers[i];\n\n        if (removalHandlers.indexOf(handler) === -1) {\n          newHandlers.push(handler);\n        }\n      }\n\n      return new EventSet(newHandlers);\n    }\n  }]);\n\n  return EventSet;\n}();\n\n/**\n * An IE11-compatible function.\n *\n * @see https://jsperf.com/suir-clone-map\n */\nfunction cloneMap(map) {\n  var newMap = new Map();\n  map.forEach(function (value, key) {\n    newMap.set(key, value);\n  });\n  return newMap;\n}\nfunction normalizeHandlers(handlers) {\n  return Array.isArray(handlers) ? handlers : [handlers];\n}\n/**\n * Asserts that the passed value is React.RefObject\n *\n * @see https://github.com/facebook/react/blob/v16.8.2/packages/react-reconciler/src/ReactFiberCommitWork.js#L665\n */\n\nvar isRefObject = function isRefObject(ref // eslint-disable-next-line\n) {\n  return ref !== null && _typeof(ref) === 'object' && ref.hasOwnProperty('current');\n};\n/**\n * Normalizes `target` for EventStack, because `target` can be passed as `boolean` or `string`.\n *\n * @see https://jsperf.com/suir-normalize-target\n */\n\nfunction normalizeTarget(target) {\n  if (target === 'document') return document;\n  if (target === 'window') return window;\n  if (isRefObject(target)) return target.current || document;\n  return target || document;\n}\n\nvar EventPool =\n/*#__PURE__*/\nfunction () {\n  function EventPool(poolName, handlerSets) {\n    _classCallCheck(this, EventPool);\n\n    _defineProperty(this, \"handlerSets\", void 0);\n\n    _defineProperty(this, \"poolName\", void 0);\n\n    this.handlerSets = handlerSets;\n    this.poolName = poolName;\n  }\n\n  _createClass(EventPool, [{\n    key: \"addHandlers\",\n    value: function addHandlers(eventType, eventHandlers) {\n      var handlerSets = cloneMap(this.handlerSets);\n\n      if (handlerSets.has(eventType)) {\n        var eventSet = handlerSets.get(eventType);\n        handlerSets.set(eventType, eventSet.addHandlers(eventHandlers));\n      } else {\n        handlerSets.set(eventType, new EventSet(eventHandlers));\n      }\n\n      return new EventPool(this.poolName, handlerSets);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventType, event) {\n      var handlerSet = this.handlerSets.get(eventType);\n      var shouldDispatchAll = this.poolName === 'default';\n\n      if (handlerSet) {\n        handlerSet.dispatchEvent(event, shouldDispatchAll);\n      }\n    }\n  }, {\n    key: \"hasHandlers\",\n    value: function hasHandlers(eventType) {\n      if (!eventType) {\n        return this.handlerSets.size > 0;\n      }\n\n      var eventSet = this.handlerSets.get(eventType);\n\n      if (eventSet) {\n        return eventSet.hasHandlers();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"removeHandlers\",\n    value: function removeHandlers(eventType, eventHandlers) {\n      var handlerSets = cloneMap(this.handlerSets);\n\n      if (!handlerSets.has(eventType)) {\n        return new EventPool(this.poolName, handlerSets);\n      }\n\n      var currentSet = handlerSets.get(eventType);\n      var nextSet = currentSet.removeHandlers(eventHandlers);\n\n      if (nextSet.hasHandlers()) {\n        handlerSets.set(eventType, nextSet);\n      } else {\n        handlerSets.delete(eventType);\n      }\n\n      return new EventPool(this.poolName, handlerSets);\n    }\n  }]);\n\n  return EventPool;\n}();\n\n_defineProperty(EventPool, \"createByType\", function (poolName, eventType, eventHandlers) {\n  var handlerSets = new Map();\n  handlerSets.set(eventType, new EventSet(eventHandlers));\n  return new EventPool(poolName, handlerSets);\n});\n\nvar EventTarget =\n/*#__PURE__*/\nfunction () {\n  function EventTarget(target) {\n    var _this = this;\n\n    _classCallCheck(this, EventTarget);\n\n    _defineProperty(this, \"handlers\", new Map());\n\n    _defineProperty(this, \"pools\", new Map());\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"createEmitter\", function (eventType) {\n      return function (event) {\n        _this.pools.forEach(function (pool) {\n          pool.dispatchEvent(eventType, event);\n        });\n      };\n    });\n\n    this.target = target;\n  }\n\n  _createClass(EventTarget, [{\n    key: \"addHandlers\",\n    value: function addHandlers(poolName, eventType, eventHandlers) {\n      if (this.pools.has(poolName)) {\n        var eventPool = this.pools.get(poolName);\n        this.pools.set(poolName, eventPool.addHandlers(eventType, eventHandlers));\n      } else {\n        this.pools.set(poolName, EventPool.createByType(poolName, eventType, eventHandlers));\n      }\n\n      if (!this.handlers.has(eventType)) {\n        this.addTargetHandler(eventType);\n      }\n    }\n  }, {\n    key: \"hasHandlers\",\n    value: function hasHandlers() {\n      return this.handlers.size > 0;\n    }\n  }, {\n    key: \"removeHandlers\",\n    value: function removeHandlers(poolName, eventType, eventHandlers) {\n      if (!this.pools.has(poolName)) {\n        return;\n      }\n\n      var pool = this.pools.get(poolName);\n      var newPool = pool.removeHandlers(eventType, eventHandlers);\n\n      if (newPool.hasHandlers()) {\n        this.pools.set(poolName, newPool);\n      } else {\n        this.pools.delete(poolName);\n      }\n\n      var hasHandlers = false;\n      this.pools.forEach(function (pool) {\n        return hasHandlers = hasHandlers || pool.hasHandlers(eventType);\n      });\n\n      if (!hasHandlers) {\n        this.removeTargetHandler(eventType);\n      }\n    }\n  }, {\n    key: \"addTargetHandler\",\n    value: function addTargetHandler(eventType) {\n      var handler = this.createEmitter(eventType);\n      this.handlers.set(eventType, handler);\n      this.target.addEventListener(eventType, handler, true);\n    }\n  }, {\n    key: \"removeTargetHandler\",\n    value: function removeTargetHandler(eventType) {\n      if (this.handlers.has(eventType)) {\n        this.target.removeEventListener(eventType, this.handlers.get(eventType), true);\n        this.handlers.delete(eventType);\n      }\n    }\n  }]);\n\n  return EventTarget;\n}();\n\nvar EventStack =\n/*#__PURE__*/\nfunction () {\n  function EventStack() {\n    var _this = this;\n\n    _classCallCheck(this, EventStack);\n\n    _defineProperty(this, \"targets\", new Map());\n\n    _defineProperty(this, \"getTarget\", function (target) {\n      var autoCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var normalized = normalizeTarget(target);\n\n      if (_this.targets.has(normalized)) {\n        return _this.targets.get(normalized);\n      }\n\n      if (!autoCreate) return null;\n      var eventTarget = new EventTarget(normalized);\n\n      _this.targets.set(normalized, eventTarget);\n\n      return eventTarget;\n    });\n\n    _defineProperty(this, \"removeTarget\", function (target) {\n      _this.targets.delete(normalizeTarget(target));\n    });\n  }\n\n  _createClass(EventStack, [{\n    key: \"sub\",\n    value: function sub(eventName, eventHandlers) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!env.canUseDOM) return;\n      var _options$target = options.target,\n          target = _options$target === void 0 ? document : _options$target,\n          _options$pool = options.pool,\n          pool = _options$pool === void 0 ? 'default' : _options$pool;\n      var eventTarget = this.getTarget(target);\n      eventTarget.addHandlers(pool, eventName, normalizeHandlers(eventHandlers));\n    }\n  }, {\n    key: \"unsub\",\n    value: function unsub(eventName, eventHandlers) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!env.canUseDOM) return;\n      var _options$target2 = options.target,\n          target = _options$target2 === void 0 ? document : _options$target2,\n          _options$pool2 = options.pool,\n          pool = _options$pool2 === void 0 ? 'default' : _options$pool2;\n      var eventTarget = this.getTarget(target, false);\n\n      if (eventTarget) {\n        eventTarget.removeHandlers(pool, eventName, normalizeHandlers(eventHandlers));\n        if (!eventTarget.hasHandlers()) this.removeTarget(target);\n      }\n    }\n  }]);\n\n  return EventStack;\n}();\n\nvar instance = new EventStack();\n\n/**\n * This component exposes the EventStack API as public and provides a declarative way to manage it.\n */\nvar EventStack$1 =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(EventStack, _React$PureComponent);\n\n  function EventStack() {\n    _classCallCheck(this, EventStack);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(EventStack).apply(this, arguments));\n  }\n\n  _createClass(EventStack, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.subscribe(this.props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.unsubscribe(prevProps);\n      this.subscribe(this.props);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.unsubscribe(this.props);\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(props) {\n      var name = props.name,\n          on = props.on,\n          pool = props.pool,\n          target = props.target;\n      instance.sub(name, on, {\n        pool: pool,\n        target: target\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(props) {\n      var name = props.name,\n          on = props.on,\n          pool = props.pool,\n          target = props.target;\n      instance.unsub(name, on, {\n        pool: pool,\n        target: target\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return EventStack;\n}(React.PureComponent);\n\n_defineProperty(EventStack$1, \"defaultProps\", {\n  pool: 'default',\n  target: 'document'\n});\nEventStack$1.propTypes = {\n  /** An event name on which we will subscribe. */\n  name: PropTypes.string.isRequired,\n\n  /** An event handler or array of event handlers. */\n  on: PropTypes.oneOfType([PropTypes.func, PropTypes.arrayOf(PropTypes.func)]).isRequired,\n\n  /** A name of pool. */\n  pool: PropTypes.string,\n\n  /** A DOM element on which we will subscribe. */\n  target: PropTypes.oneOfType([PropTypes.oneOf(['document', 'window']), // Heads up!\n  // This condition for SSR safety.\n  PropTypes.instanceOf(env.canUseDOM ? HTMLElement : Object), PropTypes.shape({\n    current: PropTypes.object\n  })])\n};\n\nexports.instance = instance;\nexports[\"default\"] = EventStack$1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbWFudGljLXVpLXJlYWN0L2V2ZW50LXN0YWNrL2xpYi9janMvZXZlbnQtc3RhY2suZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxVQUFVLG1CQUFPLENBQUMsa0RBQU87QUFDekIsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVk7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZ0JBQWdCO0FBQ2hCLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVzdGF1cmFudC8uL25vZGVfbW9kdWxlcy9Ac2VtYW50aWMtdWktcmVhY3QvZXZlbnQtc3RhY2svbGliL2Nqcy9ldmVudC1zdGFjay5kZXZlbG9wbWVudC5qcz9jNGY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGVudiA9IHJlcXVpcmUoJ2V4ZW52Jyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gd2FzIGNob3NlbiBieSBwZXJmb3JtYW5jZSBhbmQgY29tcGF0aWJpbGl0eSByZWFzb25zLCBmZWVsIGZyZWUgdG8gcGxheVxuICogd2l0aCBiZW5jaG1hcmtzIGFuZCBzdWJtaXQgUFIgd2l0aCBmYXN0ZXIgYWx0ZXJuYXRpdmUuIEVhY2ggbWV0aG9kIGNvbnRhaW5zIGxpbmtzIHRvIGJlbmNobWFya3MuXG4gKi9cbnZhciBFdmVudFNldCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vanNwZXJmLmNvbS9zdWlyLWV2ZW50c2V0LWNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBFdmVudFNldChldmVudEhhbmRsZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50U2V0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0gZXZlbnRIYW5kbGVycy5zbGljZSgwKTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBodHRwczovL2pzcGVyZi5jb20vc3Vpci1ldmVudHNldC1hZGRoYW5kbGVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudFNldCwgW3tcbiAgICBrZXk6IFwiYWRkSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSGFuZGxlcnMoYWRkaXRpb25hbEhhbmRsZXJzKSB7XG4gICAgICB2YXIgbmV3SGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzLnNsaWNlKDApO1xuICAgICAgdmFyIGxlbmd0aCA9IGFkZGl0aW9uYWxIYW5kbGVycy5sZW5ndGg7IC8vIEhlYWRzIHVwIVxuICAgICAgLy8gUHJldmlvdXNseSB3ZSB1c2UgU2V0IHRoZXJlLCBpdCBncmFudGVkIHVuaXF1ZW5lc3Mgb2YgaGFuZGxlcnMsIG5vdyBkaXNwYXRjaEV2ZW50KCkgaXNcbiAgICAgIC8vIHJlc3BvbnNpYmxlIGZvciB0aGlzLlxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIG5ld0hhbmRsZXJzLnB1c2goYWRkaXRpb25hbEhhbmRsZXJzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFdmVudFNldChuZXdIYW5kbGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9qc3BlcmYuY29tL3N1aXItZXZlbnRzZXQtZGlzcGF0Y2hzaW5nbGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vanNwZXJmLmNvbS9zdWlyLWV2ZW50c2V0LWRpc3BhdGNobXVsdGlwbGUyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQsIGRpc3BhdGNoQWxsKSB7XG4gICAgICB2YXIgY291bnQgPSB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmICghZGlzcGF0Y2hBbGwpIHtcbiAgICAgICAgLy8gSGVhZHMgdXAhXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSAucG9wKCkgdGhlcmUgYmVjYXVzZSBpdCB3aWxsIG11dGF0ZSB0aGUgYXJyYXkuXG4gICAgICAgIHZhciByZWNlbnRIYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tjb3VudF07XG4gICAgICAgIHJlY2VudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBjb3VudDsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXJzW2ldLmNhbGxlZCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlcnNbaV0uY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhhbmRsZXJzW2ldKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IGNvdW50OyBfaSA+PSAwOyBfaSAtPSAxKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbX2ldLmNhbGxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNIYW5kbGVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9qc3BlcmYuY29tL3N1aXItZXZlbnRzZXQtcmVtb3ZlaGFuZGxlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXJzKHJlbW92YWxIYW5kbGVycykge1xuICAgICAgdmFyIG5ld0hhbmRsZXJzID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5oYW5kbGVycy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2ldO1xuXG4gICAgICAgIGlmIChyZW1vdmFsSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRXZlbnRTZXQobmV3SGFuZGxlcnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudFNldDtcbn0oKTtcblxuLyoqXG4gKiBBbiBJRTExLWNvbXBhdGlibGUgZnVuY3Rpb24uXG4gKlxuICogQHNlZSBodHRwczovL2pzcGVyZi5jb20vc3Vpci1jbG9uZS1tYXBcbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwKSB7XG4gIHZhciBuZXdNYXAgPSBuZXcgTWFwKCk7XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgbmV3TWFwLnNldChrZXksIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBuZXdNYXA7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIYW5kbGVycyhoYW5kbGVycykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShoYW5kbGVycykgPyBoYW5kbGVycyA6IFtoYW5kbGVyc107XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgcGFzc2VkIHZhbHVlIGlzIFJlYWN0LlJlZk9iamVjdFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvdjE2LjguMi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyQ29tbWl0V29yay5qcyNMNjY1XG4gKi9cblxudmFyIGlzUmVmT2JqZWN0ID0gZnVuY3Rpb24gaXNSZWZPYmplY3QocmVmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuKSB7XG4gIHJldHVybiByZWYgIT09IG51bGwgJiYgX3R5cGVvZihyZWYpID09PSAnb2JqZWN0JyAmJiByZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZXMgYHRhcmdldGAgZm9yIEV2ZW50U3RhY2ssIGJlY2F1c2UgYHRhcmdldGAgY2FuIGJlIHBhc3NlZCBhcyBgYm9vbGVhbmAgb3IgYHN0cmluZ2AuXG4gKlxuICogQHNlZSBodHRwczovL2pzcGVyZi5jb20vc3Vpci1ub3JtYWxpemUtdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGFyZ2V0KHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09PSAnZG9jdW1lbnQnKSByZXR1cm4gZG9jdW1lbnQ7XG4gIGlmICh0YXJnZXQgPT09ICd3aW5kb3cnKSByZXR1cm4gd2luZG93O1xuICBpZiAoaXNSZWZPYmplY3QodGFyZ2V0KSkgcmV0dXJuIHRhcmdldC5jdXJyZW50IHx8IGRvY3VtZW50O1xuICByZXR1cm4gdGFyZ2V0IHx8IGRvY3VtZW50O1xufVxuXG52YXIgRXZlbnRQb29sID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRQb29sKHBvb2xOYW1lLCBoYW5kbGVyU2V0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudFBvb2wpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlclNldHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvb2xOYW1lXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmhhbmRsZXJTZXRzID0gaGFuZGxlclNldHM7XG4gICAgdGhpcy5wb29sTmFtZSA9IHBvb2xOYW1lO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50UG9vbCwgW3tcbiAgICBrZXk6IFwiYWRkSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSGFuZGxlcnMoZXZlbnRUeXBlLCBldmVudEhhbmRsZXJzKSB7XG4gICAgICB2YXIgaGFuZGxlclNldHMgPSBjbG9uZU1hcCh0aGlzLmhhbmRsZXJTZXRzKTtcblxuICAgICAgaWYgKGhhbmRsZXJTZXRzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgIHZhciBldmVudFNldCA9IGhhbmRsZXJTZXRzLmdldChldmVudFR5cGUpO1xuICAgICAgICBoYW5kbGVyU2V0cy5zZXQoZXZlbnRUeXBlLCBldmVudFNldC5hZGRIYW5kbGVycyhldmVudEhhbmRsZXJzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVyU2V0cy5zZXQoZXZlbnRUeXBlLCBuZXcgRXZlbnRTZXQoZXZlbnRIYW5kbGVycykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEV2ZW50UG9vbCh0aGlzLnBvb2xOYW1lLCBoYW5kbGVyU2V0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudFR5cGUsIGV2ZW50KSB7XG4gICAgICB2YXIgaGFuZGxlclNldCA9IHRoaXMuaGFuZGxlclNldHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICB2YXIgc2hvdWxkRGlzcGF0Y2hBbGwgPSB0aGlzLnBvb2xOYW1lID09PSAnZGVmYXVsdCc7XG5cbiAgICAgIGlmIChoYW5kbGVyU2V0KSB7XG4gICAgICAgIGhhbmRsZXJTZXQuZGlzcGF0Y2hFdmVudChldmVudCwgc2hvdWxkRGlzcGF0Y2hBbGwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNIYW5kbGVycyhldmVudFR5cGUpIHtcbiAgICAgIGlmICghZXZlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJTZXRzLnNpemUgPiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRTZXQgPSB0aGlzLmhhbmRsZXJTZXRzLmdldChldmVudFR5cGUpO1xuXG4gICAgICBpZiAoZXZlbnRTZXQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50U2V0Lmhhc0hhbmRsZXJzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcnMoZXZlbnRUeXBlLCBldmVudEhhbmRsZXJzKSB7XG4gICAgICB2YXIgaGFuZGxlclNldHMgPSBjbG9uZU1hcCh0aGlzLmhhbmRsZXJTZXRzKTtcblxuICAgICAgaWYgKCFoYW5kbGVyU2V0cy5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50UG9vbCh0aGlzLnBvb2xOYW1lLCBoYW5kbGVyU2V0cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50U2V0ID0gaGFuZGxlclNldHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICB2YXIgbmV4dFNldCA9IGN1cnJlbnRTZXQucmVtb3ZlSGFuZGxlcnMoZXZlbnRIYW5kbGVycyk7XG5cbiAgICAgIGlmIChuZXh0U2V0Lmhhc0hhbmRsZXJzKCkpIHtcbiAgICAgICAgaGFuZGxlclNldHMuc2V0KGV2ZW50VHlwZSwgbmV4dFNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVyU2V0cy5kZWxldGUoZXZlbnRUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFdmVudFBvb2wodGhpcy5wb29sTmFtZSwgaGFuZGxlclNldHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudFBvb2w7XG59KCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShFdmVudFBvb2wsIFwiY3JlYXRlQnlUeXBlXCIsIGZ1bmN0aW9uIChwb29sTmFtZSwgZXZlbnRUeXBlLCBldmVudEhhbmRsZXJzKSB7XG4gIHZhciBoYW5kbGVyU2V0cyA9IG5ldyBNYXAoKTtcbiAgaGFuZGxlclNldHMuc2V0KGV2ZW50VHlwZSwgbmV3IEV2ZW50U2V0KGV2ZW50SGFuZGxlcnMpKTtcbiAgcmV0dXJuIG5ldyBFdmVudFBvb2wocG9vbE5hbWUsIGhhbmRsZXJTZXRzKTtcbn0pO1xuXG52YXIgRXZlbnRUYXJnZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50VGFyZ2V0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIG5ldyBNYXAoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb29sc1wiLCBuZXcgTWFwKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidGFyZ2V0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjcmVhdGVFbWl0dGVyXCIsIGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMucG9vbHMuZm9yRWFjaChmdW5jdGlvbiAocG9vbCkge1xuICAgICAgICAgIHBvb2wuZGlzcGF0Y2hFdmVudChldmVudFR5cGUsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRUYXJnZXQsIFt7XG4gICAga2V5OiBcImFkZEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEhhbmRsZXJzKHBvb2xOYW1lLCBldmVudFR5cGUsIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgIGlmICh0aGlzLnBvb2xzLmhhcyhwb29sTmFtZSkpIHtcbiAgICAgICAgdmFyIGV2ZW50UG9vbCA9IHRoaXMucG9vbHMuZ2V0KHBvb2xOYW1lKTtcbiAgICAgICAgdGhpcy5wb29scy5zZXQocG9vbE5hbWUsIGV2ZW50UG9vbC5hZGRIYW5kbGVycyhldmVudFR5cGUsIGV2ZW50SGFuZGxlcnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9vbHMuc2V0KHBvb2xOYW1lLCBFdmVudFBvb2wuY3JlYXRlQnlUeXBlKHBvb2xOYW1lLCBldmVudFR5cGUsIGV2ZW50SGFuZGxlcnMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhhbmRsZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgIHRoaXMuYWRkVGFyZ2V0SGFuZGxlcihldmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNIYW5kbGVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLnNpemUgPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVIYW5kbGVycyhwb29sTmFtZSwgZXZlbnRUeXBlLCBldmVudEhhbmRsZXJzKSB7XG4gICAgICBpZiAoIXRoaXMucG9vbHMuaGFzKHBvb2xOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb29sID0gdGhpcy5wb29scy5nZXQocG9vbE5hbWUpO1xuICAgICAgdmFyIG5ld1Bvb2wgPSBwb29sLnJlbW92ZUhhbmRsZXJzKGV2ZW50VHlwZSwgZXZlbnRIYW5kbGVycyk7XG5cbiAgICAgIGlmIChuZXdQb29sLmhhc0hhbmRsZXJzKCkpIHtcbiAgICAgICAgdGhpcy5wb29scy5zZXQocG9vbE5hbWUsIG5ld1Bvb2wpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb29scy5kZWxldGUocG9vbE5hbWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzSGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9vbHMuZm9yRWFjaChmdW5jdGlvbiAocG9vbCkge1xuICAgICAgICByZXR1cm4gaGFzSGFuZGxlcnMgPSBoYXNIYW5kbGVycyB8fCBwb29sLmhhc0hhbmRsZXJzKGV2ZW50VHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFoYXNIYW5kbGVycykge1xuICAgICAgICB0aGlzLnJlbW92ZVRhcmdldEhhbmRsZXIoZXZlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGFyZ2V0SGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUYXJnZXRIYW5kbGVyKGV2ZW50VHlwZSkge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmNyZWF0ZUVtaXR0ZXIoZXZlbnRUeXBlKTtcbiAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVRhcmdldEhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0SGFuZGxlcihldmVudFR5cGUpIHtcbiAgICAgIGlmICh0aGlzLmhhbmRsZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB0aGlzLmhhbmRsZXJzLmdldChldmVudFR5cGUpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5kZWxldGUoZXZlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRUYXJnZXQ7XG59KCk7XG5cbnZhciBFdmVudFN0YWNrID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRTdGFjaygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50U3RhY2spO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidGFyZ2V0c1wiLCBuZXcgTWFwKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VGFyZ2V0XCIsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciBhdXRvQ3JlYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcblxuICAgICAgaWYgKF90aGlzLnRhcmdldHMuaGFzKG5vcm1hbGl6ZWQpKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50YXJnZXRzLmdldChub3JtYWxpemVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRvQ3JlYXRlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBldmVudFRhcmdldCA9IG5ldyBFdmVudFRhcmdldChub3JtYWxpemVkKTtcblxuICAgICAgX3RoaXMudGFyZ2V0cy5zZXQobm9ybWFsaXplZCwgZXZlbnRUYXJnZXQpO1xuXG4gICAgICByZXR1cm4gZXZlbnRUYXJnZXQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZW1vdmVUYXJnZXRcIiwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgX3RoaXMudGFyZ2V0cy5kZWxldGUobm9ybWFsaXplVGFyZ2V0KHRhcmdldCkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50U3RhY2ssIFt7XG4gICAga2V5OiBcInN1YlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWIoZXZlbnROYW1lLCBldmVudEhhbmRsZXJzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICBpZiAoIWVudi5jYW5Vc2VET00pIHJldHVybjtcbiAgICAgIHZhciBfb3B0aW9ucyR0YXJnZXQgPSBvcHRpb25zLnRhcmdldCxcbiAgICAgICAgICB0YXJnZXQgPSBfb3B0aW9ucyR0YXJnZXQgPT09IHZvaWQgMCA/IGRvY3VtZW50IDogX29wdGlvbnMkdGFyZ2V0LFxuICAgICAgICAgIF9vcHRpb25zJHBvb2wgPSBvcHRpb25zLnBvb2wsXG4gICAgICAgICAgcG9vbCA9IF9vcHRpb25zJHBvb2wgPT09IHZvaWQgMCA/ICdkZWZhdWx0JyA6IF9vcHRpb25zJHBvb2w7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQgPSB0aGlzLmdldFRhcmdldCh0YXJnZXQpO1xuICAgICAgZXZlbnRUYXJnZXQuYWRkSGFuZGxlcnMocG9vbCwgZXZlbnROYW1lLCBub3JtYWxpemVIYW5kbGVycyhldmVudEhhbmRsZXJzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc3ViXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3ViKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVycykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgaWYgKCFlbnYuY2FuVXNlRE9NKSByZXR1cm47XG4gICAgICB2YXIgX29wdGlvbnMkdGFyZ2V0MiA9IG9wdGlvbnMudGFyZ2V0LFxuICAgICAgICAgIHRhcmdldCA9IF9vcHRpb25zJHRhcmdldDIgPT09IHZvaWQgMCA/IGRvY3VtZW50IDogX29wdGlvbnMkdGFyZ2V0MixcbiAgICAgICAgICBfb3B0aW9ucyRwb29sMiA9IG9wdGlvbnMucG9vbCxcbiAgICAgICAgICBwb29sID0gX29wdGlvbnMkcG9vbDIgPT09IHZvaWQgMCA/ICdkZWZhdWx0JyA6IF9vcHRpb25zJHBvb2wyO1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQodGFyZ2V0LCBmYWxzZSk7XG5cbiAgICAgIGlmIChldmVudFRhcmdldCkge1xuICAgICAgICBldmVudFRhcmdldC5yZW1vdmVIYW5kbGVycyhwb29sLCBldmVudE5hbWUsIG5vcm1hbGl6ZUhhbmRsZXJzKGV2ZW50SGFuZGxlcnMpKTtcbiAgICAgICAgaWYgKCFldmVudFRhcmdldC5oYXNIYW5kbGVycygpKSB0aGlzLnJlbW92ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudFN0YWNrO1xufSgpO1xuXG52YXIgaW5zdGFuY2UgPSBuZXcgRXZlbnRTdGFjaygpO1xuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGV4cG9zZXMgdGhlIEV2ZW50U3RhY2sgQVBJIGFzIHB1YmxpYyBhbmQgcHJvdmlkZXMgYSBkZWNsYXJhdGl2ZSB3YXkgdG8gbWFuYWdlIGl0LlxuICovXG52YXIgRXZlbnRTdGFjayQxID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRXZlbnRTdGFjaywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEV2ZW50U3RhY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50U3RhY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihFdmVudFN0YWNrKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudFN0YWNrLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdGhpcy51bnN1YnNjcmliZShwcmV2UHJvcHMpO1xuICAgICAgdGhpcy5zdWJzY3JpYmUodGhpcy5wcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShwcm9wcykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgICAgIG9uID0gcHJvcHMub24sXG4gICAgICAgICAgcG9vbCA9IHByb3BzLnBvb2wsXG4gICAgICAgICAgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgICAgaW5zdGFuY2Uuc3ViKG5hbWUsIG9uLCB7XG4gICAgICAgIHBvb2w6IHBvb2wsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUocHJvcHMpIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcHMubmFtZSxcbiAgICAgICAgICBvbiA9IHByb3BzLm9uLFxuICAgICAgICAgIHBvb2wgPSBwcm9wcy5wb29sLFxuICAgICAgICAgIHRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgICAgIGluc3RhbmNlLnVuc3ViKG5hbWUsIG9uLCB7XG4gICAgICAgIHBvb2w6IHBvb2wsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudFN0YWNrO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KEV2ZW50U3RhY2skMSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBwb29sOiAnZGVmYXVsdCcsXG4gIHRhcmdldDogJ2RvY3VtZW50J1xufSk7XG5FdmVudFN0YWNrJDEucHJvcFR5cGVzID0ge1xuICAvKiogQW4gZXZlbnQgbmFtZSBvbiB3aGljaCB3ZSB3aWxsIHN1YnNjcmliZS4gKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXG4gIC8qKiBBbiBldmVudCBoYW5kbGVyIG9yIGFycmF5IG9mIGV2ZW50IGhhbmRsZXJzLiAqL1xuICBvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5mdW5jKV0pLmlzUmVxdWlyZWQsXG5cbiAgLyoqIEEgbmFtZSBvZiBwb29sLiAqL1xuICBwb29sOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKiBBIERPTSBlbGVtZW50IG9uIHdoaWNoIHdlIHdpbGwgc3Vic2NyaWJlLiAqL1xuICB0YXJnZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2RvY3VtZW50JywgJ3dpbmRvdyddKSwgLy8gSGVhZHMgdXAhXG4gIC8vIFRoaXMgY29uZGl0aW9uIGZvciBTU1Igc2FmZXR5LlxuICBQcm9wVHlwZXMuaW5zdGFuY2VPZihlbnYuY2FuVXNlRE9NID8gSFRNTEVsZW1lbnQgOiBPYmplY3QpLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGN1cnJlbnQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSldKVxufTtcblxuZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRTdGFjayQxO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@semantic-ui-react/event-stack/lib/cjs/event-stack.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@semantic-ui-react/event-stack/lib/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@semantic-ui-react/event-stack/lib/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nvar stack;\n\nif (false) {} else {\n  stack = __webpack_require__(/*! ./cjs/event-stack.development.js */ \"(ssr)/./node_modules/@semantic-ui-react/event-stack/lib/cjs/event-stack.development.js\");\n}\n\nmodule.exports = stack.default;\nmodule.exports.instance = stack.instance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbWFudGljLXVpLXJlYWN0L2V2ZW50LXN0YWNrL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ2E7O0FBRWI7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixVQUFVLG1CQUFPLENBQUMsZ0lBQWtDO0FBQ3BEOztBQUVBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVzdGF1cmFudC8uL25vZGVfbW9kdWxlcy9Ac2VtYW50aWMtdWktcmVhY3QvZXZlbnQtc3RhY2svbGliL2luZGV4LmpzP2U4MjEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdGFjaztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgc3RhY2sgPSByZXF1aXJlKCcuL2Nqcy9ldmVudC1zdGFjay5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBzdGFjayA9IHJlcXVpcmUoJy4vY2pzL2V2ZW50LXN0YWNrLmRldmVsb3BtZW50LmpzJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2suZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmluc3RhbmNlID0gc3RhY2suaW5zdGFuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@semantic-ui-react/event-stack/lib/index.js\n");

/***/ })

};
;